// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tickets.sql

package models

import (
	"context"
	"database/sql"

	"github.com/jackc/pgtype"
)

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (id, created_by, created_by_type,assigned_to, team_id, category, priority, status, tags, response_time, watchers)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, created_by, created_by_type, assigned_to, team_id, category, priority, status, tags, response_time, watchers, created_at, updated_at, deleted_at
`

type CreateTicketParams struct {
	ID            string         `json:"id"`
	CreatedBy     string         `json:"createdBy"`
	CreatedByType sql.NullString `json:"createdByType"`
	AssignedTo    sql.NullString `json:"assignedTo"`
	TeamID        sql.NullString `json:"teamId"`
	Category      []string       `json:"category"`
	Priority      string         `json:"priority"`
	Status        string         `json:"status"`
	Tags          []string       `json:"tags"`
	ResponseTime  sql.NullInt64  `json:"responseTime"`
	Watchers      pgtype.JSONB   `json:"watchers"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicket,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedByType,
		arg.AssignedTo,
		arg.TeamID,
		arg.Category,
		arg.Priority,
		arg.Status,
		arg.Tags,
		arg.ResponseTime,
		arg.Watchers,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedByType,
		&i.AssignedTo,
		&i.TeamID,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Tags,
		&i.ResponseTime,
		&i.Watchers,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAdminIDs = `-- name: GetAdminIDs :many
SELECT id FROM employees WHERE role_id = (SELECT id FROM roles WHERE name = 'admin')
`

func (q *Queries) GetAdminIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAdminIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastTicketForUser = `-- name: GetLastTicketForUser :one

SELECT id 
FROM tickets 
WHERE created_by = $1 
ORDER BY created_at DESC 
LIMIT 1
`

// -- name: UpdateTicketMedia :exec
// UPDATE tickets SET image_url = $1, updated_at = Now() WHERE id = $2;
func (q *Queries) GetLastTicketForUser(ctx context.Context, createdBy string) (string, error) {
	row := q.db.QueryRow(ctx, getLastTicketForUser, createdBy)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getRecipientsEmailsAndRoles = `-- name: GetRecipientsEmailsAndRoles :many
SELECT 
    COALESCE(c.email, e.email) AS email,
    CASE 
        WHEN c.id IS NOT NULL THEN 'customer'
        WHEN e.id IS NOT NULL THEN r.name 
    END AS role
FROM (
    SELECT unnest($1::text[]) AS recipient_id  -- FIX: Using TEXT instead of UUID
) AS recipients
LEFT JOIN customers c ON c.id = recipients.recipient_id
LEFT JOIN employees e ON e.id = recipients.recipient_id
LEFT JOIN roles r ON r.id = e.role_id
`

type GetRecipientsEmailsAndRolesRow struct {
	Email string      `json:"email"`
	Role  interface{} `json:"role"`
}

func (q *Queries) GetRecipientsEmailsAndRoles(ctx context.Context, dollar_1 []string) ([]GetRecipientsEmailsAndRolesRow, error) {
	rows, err := q.db.Query(ctx, getRecipientsEmailsAndRoles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecipientsEmailsAndRolesRow{}
	for rows.Next() {
		var i GetRecipientsEmailsAndRolesRow
		if err := rows.Scan(&i.Email, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, created_by, created_by_type, assigned_to, team_id, category, priority, status, tags, response_time, watchers, created_at, updated_at, deleted_at FROM tickets WHERE id = $1
`

func (q *Queries) GetTicketByID(ctx context.Context, id string) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicketByID, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedByType,
		&i.AssignedTo,
		&i.TeamID,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Tags,
		&i.ResponseTime,
		&i.Watchers,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWatchersEmailsAndRoles = `-- name: GetWatchersEmailsAndRoles :many
SELECT 
    COALESCE(c.email, e.email) AS email,
    CASE 
        WHEN c.id IS NOT NULL THEN 'customer'
        WHEN e.id IS NOT NULL THEN r.name 
    END AS role
FROM tickets t,
LATERAL jsonb_array_elements_text(t.watchers) AS watcher_id
LEFT JOIN customers c ON c.id = watcher_id
LEFT JOIN employees e ON e.id = watcher_id
LEFT JOIN roles r ON r.id = e.role_id
WHERE t.id = $1
`

type GetWatchersEmailsAndRolesRow struct {
	Email string      `json:"email"`
	Role  interface{} `json:"role"`
}

func (q *Queries) GetWatchersEmailsAndRoles(ctx context.Context, id string) ([]GetWatchersEmailsAndRolesRow, error) {
	rows, err := q.db.Query(ctx, getWatchersEmailsAndRoles, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWatchersEmailsAndRolesRow{}
	for rows.Next() {
		var i GetWatchersEmailsAndRolesRow
		if err := rows.Scan(&i.Email, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT id, created_by, created_by_type, assigned_to, team_id, category, priority, status, tags, response_time, watchers, created_at, updated_at, deleted_at FROM tickets ORDER BY created_at DESC
`

func (q *Queries) ListTickets(ctx context.Context) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedByType,
			&i.AssignedTo,
			&i.TeamID,
			&i.Category,
			&i.Priority,
			&i.Status,
			&i.Tags,
			&i.ResponseTime,
			&i.Watchers,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketAssignment = `-- name: UpdateTicketAssignment :exec
UPDATE tickets
SET assigned_to = $1,
    team_id = $2,
    updated_at = Now()
WHERE id = $3
`

type UpdateTicketAssignmentParams struct {
	AssignedTo sql.NullString `json:"assignedTo"`
	TeamID     sql.NullString `json:"teamId"`
	ID         string         `json:"id"`
}

func (q *Queries) UpdateTicketAssignment(ctx context.Context, arg UpdateTicketAssignmentParams) error {
	_, err := q.db.Exec(ctx, updateTicketAssignment, arg.AssignedTo, arg.TeamID, arg.ID)
	return err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :exec
UPDATE tickets
SET status = $1,
    updated_at = Now()
WHERE id = $2
`

type UpdateTicketStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) error {
	_, err := q.db.Exec(ctx, updateTicketStatus, arg.Status, arg.ID)
	return err
}

const updateWachersList = `-- name: UpdateWachersList :exec
UPDATE tickets 
SET watchers = $1, 
    updated_at = NOW() 
WHERE id = $2
`

type UpdateWachersListParams struct {
	Watchers pgtype.JSONB `json:"watchers"`
	ID       string       `json:"id"`
}

func (q *Queries) UpdateWachersList(ctx context.Context, arg UpdateWachersListParams) error {
	_, err := q.db.Exec(ctx, updateWachersList, arg.Watchers, arg.ID)
	return err
}
